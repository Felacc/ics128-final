// Default coordinates set to interurban campus
let userLat = 48.49103113795146;
let userLong = -123.41514114992222;

async function getUserCoords() {
    return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
            reject({ userLat, userLong });
        }

        navigator.geolocation.getCurrentPosition(
            // success function
            (position) => {
                userLat = position.coords.latitude;
                userLong = position.coords.longitude;
                resolve({ userLat, userLong })
            },
            // error function - defaults to interurban
            () => {
                reject({ userLat, userLong });
            }
        );
    });
}

async function getPorts() {
    const response = await fetch("includes/json/ports.json");
    if (!response.ok) {
        throw new Error(`Error: ${response.statusText}`);
    }

    const ports = await response.json();
    return ports;
}

async function loadMap() {
    const { userLat, userLong } = await getUserCoords();
    const ports = await getPorts();

    let tripStarted = false; // used to keep track of if a user has started a trip for controlling state of marker popups
    let latlngsForTrip = []; // used to keep track of marker coords (used to draw leaflet polyline)
    let tripPolyline = null;
    let tripDistance = 0;
    let stops = [] // used to keep track of markers that are generated by clicking on ocean

    var map = L.map('map', {
        center: [userLat, userLong],
        zoom: 4,
    });

    // Add the tile layer
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    }).addTo(map);

    // Add a marker at Interurban or user location on load
    var marker = L.marker([userLat, userLong]).addTo(map).bindPopup("You are here!");

    // Add markers at all ports
    // Using Font Awesome icons w/ Bootstrap styling for markers
    const portIcon = L.divIcon({ html: '<i class="fa-solid fa-ship fs-5 text-primary"></i>' });
    for (const port of ports) {
        L.marker([port.coordinates[0], port.coordinates[1]], { icon: portIcon }).addTo(map).bindPopup(() => {
            const disabledStartBtn = tripStarted ? "disabled" : "";
            const disabledAddStopBtn = tripStarted ? "" : "disabled";
            const disabledEndBtn = tripStarted ? "" : "disabled";
            return `
                <h5>${port.name}</h5>
                <button type="button" id="startTripBtn" class="btn btn-primary" ${disabledStartBtn}>Start Trip</button>
                <button type="button" id="addStopBtn" class="btn btn-primary" ${disabledAddStopBtn}>Add Stop</button>
                <button type="button" id="endTripBtn" class="btn btn-primary" ${disabledEndBtn}>End Trip</button>
            `;
        });
    }

    // Add event listeners to popup start and end trip buttons
    // have to add an event listener to detect when popups open first, because popups are added to the dom only when they are opened (i think)
    map.on("popupopen", (e) => {
        const popup = e.popup.getElement();
        const markerLatlng = e.popup._latlng;
        const startTripBtn = $(popup).find("#startTripBtn");
        const addStopBtn = $(popup).find("#addStopBtn");
        const endTripBtn = $(popup).find("#endTripBtn");

        startTripBtn.on("click", () => {
            latlngsForTrip = []; // empty array from previous trip
            if (tripPolyline) {tripPolyline.setLatLngs([]);} // reset polyline
            tripDistance = 0; // reset distance
            for (stop of stops) { // remove stop markers
                stop.remove();
            } 
            // the if is not needed for this statement, but it feels nice to know that it won't run the statement if 
            console.log($("#distance"));
            $("#distance").remove(); // remove distance displayed from previous trip (if it's there)
            tripStarted = true;
            startTripBtn.prop("disabled", true);
            addStopBtn.prop("disabled", false);
            endTripBtn.prop("disabled", false);
            latlngsForTrip.push(markerLatlng);
            tripPolyline = L.polyline(latlngsForTrip, {color: "red"}).addTo(map);
        });

        addStopBtn.on("click", () => {
            latlngsForTrip.push(markerLatlng);
            tripPolyline.setLatLngs(latlngsForTrip);
            tripDistance += map.distance(latlngsForTrip[latlngsForTrip.length - 2], latlngsForTrip[latlngsForTrip.length - 1]);
        });

        endTripBtn.on("click", () => {
            tripStarted = false;
            startTripBtn.prop("disabled", false);
            addStopBtn.prop("disabled", true);
            endTripBtn.prop("disabled", true);
            latlngsForTrip.push(markerLatlng);
            tripPolyline.setLatLngs(latlngsForTrip);
            tripDistance += map.distance(latlngsForTrip[latlngsForTrip.length - 2], latlngsForTrip[latlngsForTrip.length - 1]);
            $("body").append(`<h1 id="distance">${tripDistance / 1000} km </h1>`); //km
        });
    });


    // Load and duplicate water polygons //
    // This stuff is where Joe differentiates the land and sea. DON'T Change this Stuff //
    // Unless you dont want it to work.
    let waterPolygons;
    // Duplicating the land and sea over 3 sets of world maps
    function duplicateWaterPolygons(original) {
        const offsets = [-360, 0, 360];
        const allFeatures = [];

        for (const offset of offsets) {
            const wrapped = JSON.parse(JSON.stringify(original));
            for (const feature of wrapped.features) {
                const geom = feature.geometry;
                if (geom.type === "Polygon") {
                    geom.coordinates = geom.coordinates.map(ring =>
                        ring.map(([lng, lat]) => [lng + offset, lat])
                    );
                } else if (geom.type === "MultiPolygon") {
                    geom.coordinates = geom.coordinates.map(polygon =>
                        polygon.map(ring =>
                            ring.map(([lng, lat]) => [lng + offset, lat])
                        )
                    );
                }
            }
            allFeatures.push(...wrapped.features);
        }

        return {
            type: "FeatureCollection",
            features: allFeatures
        };
    }
    // Fetching JSON data to make the boundaries
    fetch('includes/json/ocean.geojson')
        .then(res => res.json())
        .then(data => {
            waterPolygons = duplicateWaterPolygons(data);
        });

    /* Click event to detect land or water. You will have to add things and change things in here
    But you won't likely want to delete  this! */
    map.on('click', function (e) {
        if (!waterPolygons) return;
        const point = turf.point([e.latlng.lng, e.latlng.lat]);
        let isInWater = null;
        for (let feature of waterPolygons.features) {
            if (turf.booleanPointInPolygon(point, feature)) {
                isInWater = true;
                break;
            }
        }
        // if its water, do something!!! Definitely delete those alerts.
        if (isInWater) {
            if (tripStarted) {
                latlngsForTrip.push([e.latlng.lat, e.latlng.lng]);
                stops.push(L.marker([e.latlng.lat, e.latlng.lng]).addTo(map));
                tripPolyline.setLatLngs(latlngsForTrip);
                tripDistance += map.distance(latlngsForTrip[latlngsForTrip.length - 2], latlngsForTrip[latlngsForTrip.length - 1]);
        


            }
        }
    });
}

loadMap();
